'use strict';

var _createClass = function() {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];
            descriptor.enumerable = descriptor.enumerable || false;
            descriptor.configurable = true;
            if ("value" in descriptor) descriptor.writable = true;
            Object.defineProperty(target, descriptor.key, descriptor);
        }
    }
    return function(Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);
        if (staticProps) defineProperties(Constructor, staticProps);
        return Constructor;
    };
}();

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

var debounce = require('./debounce');

var createEvent = function createEvent(event, context, startTime) {
    return {
        dt: Date.now() - startTime,
        f: event,
        context: context
    };
};

var createBatch = function createBatch(events, startTime) {
    return {
        dt: Date.now() - startTime,
        e: events
    };
};

var EventBuffer = function() {
    function EventBuffer(debounceMs, maxBatchSize) {
        var _this = this;

        _classCallCheck(this, EventBuffer);

        this._maxBatchSize = maxBatchSize;
        this._flushHandler = function(x) {
            return x;
        };
        this._flushDebounced = debounce(function() {
            return _this.flush();
        }, debounceMs);

        this._init();
    }

    _createClass(EventBuffer, [{
        key: '_init',
        value: function _init() {
            var _this2 = this;

            this._startTime = Date.now();
            this._events = [];
            this._resolve = null;
            this._promise = new Promise(function(resolve) {
                return _this2._resolve = resolve;
            });
        }
    }, {
        key: 'flush',
        value: function flush() {
            if (!this._events.length) {
                return Promise.resolve();
            }

            var events = this._events;
            var resolve = this._resolve;
            var startTime = this._startTime;

            this._init();

            return this._flushHandler(createBatch(events, startTime)).then(resolve);
        }
    }, {
        key: 'onFlush',
        value: function onFlush(handler) {
            this._flushHandler = handler;

            return this;
        }
    }, {
        key: 'feed',
        value: function feed(event, context) {
            this._events.push(createEvent(event, context, this._startTime));

            if (this._events.length === this._maxBatchSize) {
                return this.flush();
            }

            this._flushDebounced();

            return this._promise;
        }
    }]);

    return EventBuffer;
}();

module.exports = EventBuffer;
//# sourceMappingURL=event-buffer.js.map