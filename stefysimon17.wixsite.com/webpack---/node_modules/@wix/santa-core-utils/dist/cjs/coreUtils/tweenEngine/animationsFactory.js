'use strict';
/*eslint no-console:0*/

var log = {
    error: function error() {
        var _console;

        return (_console = console).error.apply(_console, arguments);
    }
};
/**
 * @typedef {Object} AnimationFactory
 * @property {function} sequence
 * @property {function} resetRegistrations
 * @property {function} getTransitionsDefs
 * @property {function} registerAnimation
 * @property {function(string): (*|{})} getProperties
 * @property {function} getAnimationsDefs
 * @property {function} animate
 * @property {function} registerTransition
 * @property {function} transition
 * @property {function} getAllProperties
 */

/**
 * returns an animation factory
 * @returns {AnimationFactory}
 */

function create() {
    var defs = {
        animations: {},
        transitions: {},
        properties: {}
    };
    /**
     * Start a new sequence
     * NOTE: expects for an animation called 'BaseSequence' to be registered
     * @param [params]
     * @constructor
     */

    function SequenceBuilder(params) {
        var baseSequence = 'BaseSequence'; // I have to use a var or ESLint will be mad.

        this.timeline = defs.animations[baseSequence](params ? Object.assign({}, params) : {});
    }
    /**
     * Add another animation, transition or sequence to the sequence
     * @param {TweenMax|TimelineMax|Array} tweens
     * @param {String|number} [position='+=0']
     * @param {String|number} [align='normal']
     * @returns {SequenceBuilder}
     */


    SequenceBuilder.prototype.add = function(tweens, position, align) {
        position = typeof position === 'undefined' ? '+=0' : position;
        align = align || 'normal';
        this.timeline.add(tweens, position, align);
        return this;
    };
    /**
     * Get the real timeline attached to the sequence
     * @returns {TimelineMax}
     */


    SequenceBuilder.prototype.get = function() {
        return this.timeline;
    };
    /**
     * Add/remove Timeline event handler
     * From GSAP Docs (https://greensock.com/docs/v3/GSAP/Timeline/eventCallback()):
     * .eventCallback( type:String, callback:Function, params:Array ) : [Function | self]
     * Gets or sets an event callback like onComplete, onUpdate, onStart, onReverseComplete, or onRepeat
     * along with any parameters that should be passed to that callback.
     *
     * @param {'onComplete'|'onUpdate'|'onStart'|'onReverseComplete'|'onRepeat'} type
     * @param {function|null} handler function for adding and null for removing
     * @param {*[]} [args] rest params
     * @return {SequenceBuilder}
     */


    SequenceBuilder.prototype.event = function(type, handler) {
        var _this$timeline;

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            args[_key - 2] = arguments[_key];
        }

        (_this$timeline = this.timeline).eventCallback.apply(_this$timeline, [type, handler].concat(args));

        return this;
    };
    /**
     * Play the timeline
     * @return {SequenceBuilder}
     */


    SequenceBuilder.prototype.play = function() {
        this.timeline.play();
        return this;
    };
    /**
     * Play the timeline backwards
     * @return {SequenceBuilder}
     */


    SequenceBuilder.prototype.reverse = function() {
        this.timeline.reverse();
        return this;
    };
    /**
     * Pause the timeline
     * @return {SequenceBuilder}
     */


    SequenceBuilder.prototype.pause = function() {
        this.timeline.pause();
        return this;
    };
    /**
     * Seek the timeline
     * @return {SequenceBuilder}
     */


    SequenceBuilder.prototype.seek = function(progress) {
        this.timeline.totalProgress(progress);
        return this;
    };
    /**
     * Get the real timeline attached to the sequence
     * @return {SequenceBuilder}
     */


    SequenceBuilder.prototype.clear = function() {
        this.timeline.clear();
        return this;
    };
    /**
     * Instantiate a new SequenceBuilder
     * @variation 1
     * @param [params]
     * @returns {SequenceBuilder}
     */


    function sequence(params) {
        return new SequenceBuilder(params);
    }
    /**
     * Schedule an animation on an element
     * @variation 2
     * @param {String} name The name of the animation (ie. "FadeIn")
     * @param {Array<HTMLElement>|HTMLElement} elements DOM element to animate
     * @param {Number} [duration=1] Animation Duration in seconds
     * @param {Number} [delay=0] The time to wait in seconds before starting the animation
     * @param {Object} [params] Additional parameters for the animation
     * @returns {TweenMax|TimelineMax|null} The animation function to schedule, null if this animation is not registered
     */


    function animate(name, elements, duration, delay, params) {
        var animationsDef = defs.animations[name];

        if (!animationsDef) {
            log.error('Warning:', name, 'is not a registered animation. skipping.');
            return null;
        }

        return animationsDef(elements, duration, delay, params ? Object.assign({}, params) : {});
    }
    /**
     * Schedule an transition animation between two elements
     * The difference from "animate" is that "transition" functions receives two elements and animated between them.
     * @variation 2
     * @param {String} name The name of the animation (ie. "FadeIn")
     * @param {Array<HTMLElement>|HTMLElement} sourceElements DOM element to animate from
     * @param {Array<HTMLElement>|HTMLElement} destinationElements DOM element to animate to
     * @param {Number} [duration=1] Animation Duration in seconds
     * @param {Number} [delay=0] The time to wait in seconds before starting the animation
     * @param {Object} [params] Additional parameters for the animation
     * @returns {TimelineMax|null} The animation function to schedule, null if this animation is not registered
     */


    function transition(name, sourceElements, destinationElements, duration, delay, params) {
        var transitionsDef = defs.transitions[name];

        if (!transitionsDef) {
            log.error('Warning:', name, 'is not a registered transition. skipping.');
            return null;
        }

        return transitionsDef(sourceElements, destinationElements, duration, delay, params ? Object.assign({}, params) : {});
    }
    /**
     * This function is used by animation and transition classes to register themselves on this animations instance
     * @param {string} animationName The public name of the animation which it will be called with
     * @param {function} animationFunc The animation function
     * @param {{}} animationProperties The animation properties
     */


    function registerAnimation(animationName, animationFunc, animationProperties) {
        if (defs.transitions[animationName]) {
            log.error('Warning: there is already a transition with the name', animationName);
        }

        defs.animations[animationName] = animationFunc;
        defs.properties[animationName] = animationProperties || {};
    }
    /**
     * API Sugar. currently does the same as registerAnimation
     * This function is used by animation and transition classes to register themselves on this animations instance
     * @param {string} transitionName The public name of the animation which it will be called with
     * @param {function} transitionFunc The transition function
     * @param {{}} animationProperties The transition properties
     */


    function registerTransition(transitionName, transitionFunc, animationProperties) {
        if (defs.animations[transitionName]) {
            log.error('Warning: there is already an animation with the name', transitionName);
        }

        defs.transitions[transitionName] = transitionFunc;
        defs.properties[transitionName] = animationProperties;
    }
    /**
     * @typedef {object} AnimationProperties
     * @property {string[]} groups        - Groups (or tags) this animation or transition is assigned to
     * @property {boolean} [hideOnStart]       - Animations only: Flag notating if this animation should hide the element before starting
     * @property {number} [defaultDuration]    - Transitions only: the default transition duration
     */

    /**
     * Get special properties for the passed animation or transition name
     * @param {string} name
     * @returns {AnimationProperties}
     */


    function getProperties(name) {
        return defs.properties[name] || {};
    }

    function getAllProperties() {
        return defs.properties;
    }

    function getAnimationsDefs() {
        return defs.animations;
    }

    function getTransitionsDefs() {
        return defs.transitions;
    }

    function resetRegistrations() {
        defs.animations = {};
        defs.transitions = {};
        defs.properties = {};
    }
    /**
     * @class core.animationsFactory
     */


    return {
        animate: animate,
        transition: transition,
        sequence: sequence,
        registerAnimation: registerAnimation,
        registerTransition: registerTransition,
        getProperties: getProperties,
        getAllProperties: getAllProperties,
        getAnimationsDefs: getAnimationsDefs,
        getTransitionsDefs: getTransitionsDefs,
        resetRegistrations: resetRegistrations
    };
}

module.exports = {
    create: create
};
//# sourceMappingURL=animationsFactory.js.map