'use strict';

var domMeasurements = require('../core/domMeasurements');

function create(gsap, plugins) {
    if (plugins === void 0) {
        plugins = [];
    }

    gsap.registerPlugin.apply(gsap, plugins);
    var _allowedTweenMaxParamsList = [ //Basics
        'ease', 'duration', 'delay', 'to', 'from', 'repeat', 'yoyo', 'repeatDelay', 'easeParams', 'stagger', 'transformOrigin', //Advanced
        'clearProps', 'paused', 'overwrite', 'autoClear', 'parseTransform', 'fireUpdateCommand', 'data', 'elementClearParams', 'perspective', 'transformPerspective', 'immediateRender', 'callbacks', 'force3D', 'transformStyle'
    ];
    var _allowedTimelineMaxParamsList = [ //Basics
        'delay', 'repeat', 'yoyo', 'repeatDelay', 'stagger', //Advanced
        'paused', 'align', 'tweens', 'autoClear', 'data', 'elementClearParams', 'callbacks'
    ];
    /**
     * easeParams and old ease format is not supported on gsap3
     * old
     *    easeParams: [1, 0.5],
     *    ease: Elastic.easeOut
     * new
     *    ease: "elastic.out(1, 0.5)"
     * @param params
     */

    var convertEaseToGsap3 = function convertEaseToGsap3(params) {
        //check format
        var ease = params.ease,
            easeParams = params.easeParams;

        if (ease.includes('ease')) {
            var _ease$split = ease.split('.'),
                easeClass = _ease$split[0],
                easeType = _ease$split[1];

            easeClass = easeClass.charAt(0).toLowerCase() + easeClass.slice(1);
            easeType = easeType.replace('ease', '');
            easeType = easeType.charAt(0).toLowerCase() + easeType.slice(1);
            var easeConfig = Array.isArray(easeParams) ? "(" + easeParams.join(',') + ")" : '';
            params.ease = (easeClass + "." + easeType + easeConfig).replace('linear.', '');
            delete params.easeParams;
        }
    };

    var convertParamsToGsap3 = [{
        ease: convertEaseToGsap3
    }];
    /**
     * union 2 arrays
     * @param  {Array<String>} a
     * @param  {Array<String>} b
     * @returns {Array<String>}
     * @private
     */

    var _unionArrays = function _unionArrays(a, b) {
        return Array.from(new Set([].concat(a, b)));
    };
    /**
     * Animate an element.
     * Passed params are being validated and filtered against _allowedTweenMaxParamsList list
     * @param {Array<HTMLElement>|HTMLElement} elements DOM element to animate
     * @param {import("./tweenEngineGreenSock").TweenParams} params
     * @param {Array<String>} allowedAnimationParamsList a list of tween parameters allowed for this tween
     * @returns {TweenMax}
     */


    function tween(elements, params, allowedAnimationParamsList) {
        if (params === void 0) {
            params = {};
        }

        var tweenFunc; // We handle only Arrays

        if (!Array.isArray(elements)) {
            var isNodeList = elements instanceof window.NodeList; // @ts-ignore

            elements = isNodeList ? Array.from(elements) : [elements];
        }

        var allowedParamsUnioned = _unionArrays(allowedAnimationParamsList, _allowedTweenMaxParamsList);

        params = _validateAnimationParams(params, allowedParamsUnioned);

        _assignCallbacks(params);

        if (params.from && params.to) {
            tweenFunc = _fromTo;
        } else if (params.from) {
            tweenFunc = _from;
        } else {
            tweenFunc = _to;
        }

        return tweenFunc(elements, params);
    }
    /**
     * Accepts a list of tweenMax arguments and returns a timeline with all the returned tweens timelined to the timeline 0 mark
     * Passed params are being validated and filtered against _allowedTimelineMaxParamsList list
     * @variation 3
     * @param {import("./tweenEngineGreenSock").TweenParams} [params] extra tweenEngine parameters
     * @param {Array<String>} [allowedAnimationParamsList] a list of tween parameters allowed for this tween
     * @returns {TimelineMax}
     */


    function timeline(params, allowedAnimationParamsList) {
        var allowedParamsUnioned = _unionArrays(allowedAnimationParamsList, _allowedTimelineMaxParamsList);

        params = _validateAnimationParams(params, allowedParamsUnioned);

        _assignCallbacks(params);

        return gsap.timeline(params);
    }
    /**
     * Calls a tween of 0 seconds duration, equivalent to TweenMax 'set' just with our engine syntax and callbacks
     * @param {Array<HTMLElement>|HTMLElement} elements DOM element to animate
     * @param {Object} params the tween params passed by the animation resource (no need to 'to' or 'from', always defaults to 'to')
     * @returns {TweenMax}
     */


    function set(elements, params) {
        if (params === void 0) {
            params = {};
        }

        params.duration = 0;
        params.delay = 0;
        params.to = params.to || {};
        return tween(elements, params, Object.keys(params));
    }
    /**
     * Kill a tween or timeline and invoke a callback if passed
     * Before killing the animation set the position of the play head to the end of the animation (simulate completion)
     * @param {TweenMax|TimelineMax} src
     * @param {number} [seekTo] when stopping the animation - keep the components in their current state or seek to the end of the animation.
     */


    function kill(src, seekTo) {
        if (!src.paused()) {
            src.pause();

            _onInterruptHandler();
        } // @ts-ignore


        if (!isNaN(parseFloat(seekTo)) && isFinite(seekTo)) {
            src.progress(seekTo, true);
        }

        src.kill();

        if (src.clear) {
            src.clear();
        }
    }
    /**
     * Adds a ticker ( wrapper for requestAnimationFrame / setTimeout 60FPS )
     * We are telling the browser that we wish to perform ( usually an animation ) and that the callback should be called before the next repaint
     * @param {Function} callback
     */


    function addTickerEvent(callback) {
        gsap.ticker.add(callback);
    }
    /**
     * Removes the registered ticker function
     * @param {Function} callback
     */


    function removeTickerEvent(callback) {
        gsap.ticker.remove(callback);
    }
    /**
     * Return if the passed element is in the middle of an animation
     * @param {HTMLElement} element
     * @returns {boolean}
     */


    function isTweening(element) {
        return gsap.isTweening(element);
    }
    /**
     * Return all tweens on an element
     * @param {HTMLElement} element
     * @param {boolean} [isActive] return only running tweens
     * @returns {Array.<TweenMax>}
     */


    function getTweensOf(element, isActive) {
        return gsap.getTweensOf(element, isActive);
    }
    /**
     * Set a new "from" animation, the animation will end at the default state of the element
     * a clone of the passed params object is saved on the tweenMax's 'data' object
     * @param {Array.<HTMLElement>|HTMLElement} elements DOM element or DOM Id
     * param {Object} params the parameters for the animation
     * @param {{stagger?: string|number, from?: *, data?: *, delay?: *}} params use stagger
     * @returns {TweenMax}
     * @private
     */


    function _from(elements, params) {
        if (params === void 0) {
            params = {};
        }

        var tw;
        var seq;
        var fromParams = Object.assign({}, params.from, params);
        fromParams.data = fromParams.data || {};
        delete fromParams.from;

        if (typeof fromParams.stagger !== 'undefined') {
            var _params = params,
                data = _params.data;
            var _params2 = params,
                delay = _params2.delay;
            fromParams.data = {};
            delete fromParams.delay;
            tw = gsap.from(elements, fromParams);
            seq = timeline({
                data: data,
                delay: delay
            }).add(tw);
        } else {
            tw = gsap.from(elements, fromParams);
        }

        return seq || tw;
    }
    /**
     * Set a new "to" animation, the animation will start at the default state of the element
     * a clone of the passed params object is saved on the tweenMax's 'data' object
     * @param {Array<HTMLElement>|HTMLElement} elements DOM element or DOM Id
     * @param {Object} params the parameters for the animation
     * @param {string|number} [params.stagger] use stagger
     * @param {string|number} [params.to] use stagger
     * @param {*} [params.data] use stagger
     * @param {string|number} [params.delay] use stagger
     * @returns {TweenMax}
     * @private
     */


    function _to(elements, params) {
        if (params === void 0) {
            params = {};
        }

        var tw;
        var seq;
        var toParams = Object.assign({}, params.to, params);
        toParams.data = toParams.data || {};
        delete toParams.to;

        if (typeof toParams.stagger !== 'undefined') {
            var _params3 = params,
                data = _params3.data;
            var _params4 = params,
                delay = _params4.delay;
            toParams.data = {};
            delete toParams.delay;
            tw = gsap.to(elements, toParams);
            seq = timeline({
                data: data,
                delay: delay
            }).add(tw);
        } else {
            tw = gsap.to(elements, toParams);
        }

        return seq || tw;
    }
    /**
     * Set a new "fromTo" animation
     * a clone of the passed params object is saved on the tweenMax's 'data' object
     * @param {Array.<HTMLElement>|HTMLElement} elements DOM element or DOM Id
     * @param {Object} params the parameters for the animation
     * @returns {TweenMax}
     * @private
     */


    function _fromTo(elements, params) {
        var fromParams = params.from,
            toParams = params.to;
        toParams.data = toParams.data || {};
        delete params.to;
        delete params.from;
        Object.assign(toParams, params);
        return gsap.fromTo(elements, fromParams, toParams);
    }

    function _assignCallbacks(params) {
        params.data = params.data || {};

        if (params.callbacks) {
            params.data.callbacks = {};

            if (params.callbacks.onComplete) {
                params.data.callbacks.onComplete = params.callbacks.onComplete;
                params.onComplete = _onCompleteHandler;
            }

            if (params.callbacks.onReverseComplete) {
                params.data.callbacks.onReverseComplete = params.callbacks.onReverseComplete;
                params.onReverseComplete = _onReverseCompleteHandler;
            }

            if (params.callbacks.onStart) {
                params.data.callbacks.onStart = params.callbacks.onStart;
                params.onStart = _onStartHandler;
            }

            if (params.callbacks.onUpdate) {
                params.data.callbacks.onUpdate = params.callbacks.onUpdate;
                params.onUpdate = _onUpdateHandler;
            }

            if (params.callbacks.onInterrupt) {
                params.data.callbacks.onInterrupt = params.callbacks.onInterrupt;
            }
        }

        delete params.callbacks;
        return params;
    }
    /**
     * OnComplete callback for tweens and timelines
     * @private
     */


    function _onCompleteHandler() {
        _callHandlerIfExists(this, 'onComplete');
    }
    /**
     * OnReverseComplete callback for tweens and timelines
     * @private
     */


    function _onReverseCompleteHandler() {
        _callHandlerIfExists(this, 'onReverseComplete');
    }
    /**
     * OnStart callback for tweens and timelines
     * @private
     */


    function _onStartHandler() {
        _callHandlerIfExists(this, 'onStart');
    }
    /**
     * OnUpdate callback (will invoke every animationFrame) for tweens and timelines
     * @private
     */


    function _onUpdateHandler() {
        _callHandlerIfExists(this, 'onUpdate');
    }
    /**
     * OnUpdate callback (will invoke every animationFrame) for tweens and timelines
     * @private
     */


    function _onInterruptHandler() {
        _callHandlerIfExists(this, 'onInterrupt');
    }

    function _callHandlerIfExists(sequenceOrTimeline, eventName) {
        if (sequenceOrTimeline === void 0) {
            sequenceOrTimeline = {};
        }

        var _sequenceOrTimeline = sequenceOrTimeline,
            data = _sequenceOrTimeline.data;
        var eventHandler = data && data.callbacks && data.callbacks[eventName];

        if (typeof eventHandler === 'function') {
            sequenceOrTimeline.data.callbacks[eventName](sequenceOrTimeline);
        }
    }
    /**
     * Removes from the passed params object values that are not present in the union of allowedAnimationParamsList and this._allowedTweenMaxParamsList
     * @param {Object} params
     * @param {string[]} allowedAnimationParamsLists array of allowed params for this animation
     * @returns {Object}
     * @private
     */


    function _validateAnimationParams(params, allowedAnimationParamsLists) {
        if (params === void 0) {
            params = {};
        }

        Object.keys(params).forEach(function(key) {
            // If the parameter is 'to' of 'from' (for fromTo animations)
            // run validation on the second level
            if (key === 'to' || key === 'from') {
                _validateAnimationParams(params[key], allowedAnimationParamsLists);
            } else if (!allowedAnimationParamsLists.includes(key)) {
                delete params[key];
            } else {
                //handle gsap3 params deprecation
                var modifierItem = convertParamsToGsap3.find(function(item) {
                    return item[key];
                });

                if (modifierItem) {
                    modifierItem[key](params);
                }
            }
        });
        return params;
    }

    function delayedCall(delay, callback, params, scope) {
        return gsap.delayedCall(delay, callback, params, scope);
    }
    /**
     *
     * @param src
     * @param {number} duration
     * @param {number} from
     * @param {number} to
     * @param {string} [easing=Linear.easeOut]
     * @param {{onStart:function, onUpdate:function, onComplete:function}} [callbacks]
     * @returns {*}
     */


    function animateTimeScale(src, duration, from, to, easing, callbacks) {
        var fromParams = {
            timeScale: from
        };
        var toParams = {
            duration: duration,
            timeScale: to,
            easing: easing || 'Linear.easeNone'
        };

        if (callbacks) {
            Object.assign(toParams, callbacks);
        }

        if (from === 0 && src.paused()) {
            src.play();
        }

        return gsap.fromTo(src, fromParams, toParams);
    }
    /**
     * Utility function, USE WITH CAUTION.
     * see http://greensock.com/docs/#/HTML5/GSAP/TweenMax/static_lagSmoothing/
     * @param {number} threshold
     * @param {number} [adjustedLag] optional if threshold is 0;
     */


    function adjustLagSmoothing(threshold, adjustedLag) {
        //tweenMax is not loaded on server side rendering and tests, so testing for existence
        if (typeof gsap.lagSmoothing === 'function') {
            gsap.lagSmoothing(threshold, adjustedLag);
        }
    }
    /**
     * Utility function, USE WITH CAUTION.
     * see http://greensock.com/docs/#/HTML5/All/TweenLite/ticker/
     * @param {boolean} isRaf
     */


    function useRAF(isRaf) {
        if (gsap.ticker && typeof gsap.ticker.useRAF === 'function') {
            gsap.ticker.useRAF(isRaf);
        }
    }
    /**
     * @class core.animations.tweenEngineGreenSock
     */


    return {
        timeline: timeline,
        tween: tween,
        set: set,
        kill: kill,
        addTickerEvent: addTickerEvent,
        removeTickerEvent: removeTickerEvent,
        isTweening: isTweening,
        getTweensOf: getTweensOf,
        getElementRect: domMeasurements.getElementRect,
        getContentRect: domMeasurements.getContentRect,
        getBoundingRect: domMeasurements.getBoundingRect,
        getBoundingContentRect: domMeasurements.getBoundingContentRect,
        delayedCall: delayedCall,
        animateTimeScale: animateTimeScale,
        adjustLagSmoothing: adjustLagSmoothing,
        useRAF: useRAF
    };
}

module.exports = {
    create: create
};
//# sourceMappingURL=tweenEngineGreenSock3.js.map