import {
    joinURL,
    unique
} from '../../utils/utils';
import {
    setAttributes,
    setStyle,
    fittingTypeToObjectFit
} from '../../utils/domUtils';
import imageClientApi from '@wix/image-client-api/dist/imageClientApi';
export default {
    /**
     * @param {HTMLVideoElement} videoNode
     * @param {HTMLDivElement} container
     * @param {boolean} hasBgScrollEffect
     * @param {number} videoWidth
     * @param {number} videoHeight
     * @param {string} fittingType
     * @param {string} alignType
     * @param {Object[]} qualities
     * @param {string} staticVideoUrl
     * @param {string} videoId
     * @param {string} videoFormat
     * @param {{x: number, y:number}} focalPoint
     * @return {{currentSrc: string, videoStyle: {top: number, left: number, width: number, height: number}, videoSourceUrl: string}}
     */
    measure: function measure(videoNode, container, _ref) {
        var hasBgScrollEffect = _ref.hasBgScrollEffect,
            videoWidth = _ref.videoWidth,
            videoHeight = _ref.videoHeight,
            fittingType = _ref.fittingType,
            _ref$alignType = _ref.alignType,
            alignType = _ref$alignType === void 0 ? 'center' : _ref$alignType,
            qualities = _ref.qualities,
            staticVideoUrl = _ref.staticVideoUrl,
            videoId = _ref.videoId,
            videoFormat = _ref.videoFormat,
            focalPoint = _ref.focalPoint;
        // if background has a full-height scroll effect we use the parent width,
        // the element position is fixed and without explicit width it will take
        // the viewport's width or the width of an ancestor with a transform (i.e. page in transition)
        var width = hasBgScrollEffect ? container.offsetWidth : videoNode.parentElement.offsetWidth;
        var height = videoNode.parentElement.offsetHeight;
        var vidWidth = parseInt(videoWidth, 10);
        var vidHeight = parseInt(videoHeight, 10);
        var scaleFactor = getScaleFactor(width, height, vidWidth, vidHeight);
        var videoScaledDimensions = getVideoDimension(fittingType, scaleFactor, vidWidth, vidHeight);
        var targetQuality = getVideoQualityBySize(qualities, videoScaledDimensions);
        var videoSourceUrl = getMP4Url(targetQuality, staticVideoUrl, videoId, videoFormat);
        var needsSrcUpdate = shouldUpdateSrc(videoNode, videoSourceUrl);
        var objectFit = fittingTypeToObjectFit[fittingType] || 'cover';
        var focalPosition = focalPoint ? convertFillFocalToPosition(videoScaledDimensions, {
            width: width,
            height: height
        }, focalPoint) : '';
        var alignTypeString = alignType.replace('_', ' ');
        return {
            videoSourceUrl: videoSourceUrl,
            needsSrcUpdate: needsSrcUpdate,
            videoStyle: {
                width: '100%',
                height: '100%',
                objectFit: objectFit,
                objectPosition: focalPosition ? focalPosition : alignTypeString
            }
        };
    },

    /**
     * @param {HTMLDivElement} poster
     * @param {HTMLCanvasElement|null} canvas
     * @param {HTMLVideoElement} videoNode
     * @param {Object} videoStyle
     * @param {boolean} autoPlay
     * @param {string} videoSourceUrl
     * @param {boolean} needsSrcUpdate
     * @param {string} animatePoster
     * @param {string} videoFormat
     * @param {number} playbackRate
     * @param {boolean} isEditorMode
     */
    mutate: function mutate(poster, canvas, videoNode, videoStyle, autoPlay, videoSourceUrl, needsSrcUpdate, animatePoster, videoFormat, playbackRate, isEditorMode) {
        setAttributes(videoNode, {
            width: videoStyle.width,
            height: videoStyle.height
        });

        if (canvas) {
            setStyle(canvas, videoStyle);
        } else {
            handlePosterVisibility(needsSrcUpdate, videoNode, poster, animatePoster, autoPlay, isEditorMode);

            if (autoPlay) {
                videoNode.setAttribute('autoplay', '');
            } else {
                videoNode.removeAttribute('autoplay');
            }

            setStyle(videoNode, videoStyle);
        }

        patchVideoSource(needsSrcUpdate, videoNode, videoSourceUrl);
        videoNode.playbackRate = playbackRate;
    }
};
/**
 *
 * @param videoNode
 * @param newSrcUrl
 * @returns {*|boolean}
 */

function shouldUpdateSrc(videoNode, newSrcUrl) {
    var hasError = videoNode.networkState === videoNode.NETWORK_NO_SOURCE;
    var hasDiff = !videoNode.currentSrc.endsWith(newSrcUrl);
    return newSrcUrl && (hasDiff || hasError);
}
/**
 * Calculate width and height of video's
 * visible rect according to provided `fittingType`.
 *
 * @param {string} fittingType
 * @param {{wScale: number, hScale: number}} videoScale
 * @param {number} videoWidth
 * @param {number} videoHeight
 * @return {{width: number, height: number}}
 */


function getVideoDimension(fittingType, videoScale, videoWidth, videoHeight) {
    var scale;

    if (fittingType === imageClientApi.fittingTypes.SCALE_TO_FIT) {
        scale = Math.min(videoScale.wScale, videoScale.hScale);
    } else {
        // default: imageClientApi.fittingTypes.SCALE_TO_FILL
        scale = Math.max(videoScale.wScale, videoScale.hScale);
    }

    return {
        width: Math.round(videoWidth * scale),
        height: Math.round(videoHeight * scale)
    };
}
/**
 * Calculate ratio between video's width and height, and its container's.
 *
 * @param {number} containerWidth
 * @param {number} containerHeight
 * @param {number} videoWidth
 * @param {number} videoHeight
 * @return {{wScale: number, hScale: number}}
 */


function getScaleFactor(containerWidth, containerHeight, videoWidth, videoHeight) {
    return {
        wScale: containerWidth / videoWidth,
        hScale: containerHeight / videoHeight
    };
}
/**
 * Pick the desired video quality from a list of given qualities
 * according to visible rect dimensions.
 *
 * @param {Object[]} qualities
 * @param {{width: number, height: number}} videoScaledDimensions
 * @return {Object} the quality to use
 */


function getVideoQualityBySize(qualities, _ref2) {
    var width = _ref2.width,
        height = _ref2.height;
    var uniqueQualities = unique(qualities, function(item) {
        return item.size;
    });
    var targetQuality = uniqueQualities.find(function(value) {
        return value.size > width * height;
    });
    return targetQuality || qualities[qualities.length - 1];
}
/**
 * Get a full URL for the video if playing MP4 format, or empty string otherwise.
 *
 * @param {Object} targetQuality
 * @param {string} staticVideoUrl
 * @param {string} videoId
 * @param {string} videoFormat
 * @returns {string}
 */


function getMP4Url(targetQuality, staticVideoUrl, videoId, videoFormat) {
    if (videoFormat === 'mp4') {
        // prefer video URL from new design data structure
        if (targetQuality.url) {
            return joinURL(staticVideoUrl, targetQuality.url);
        } // build URL from videoId


        return joinURL(staticVideoUrl, videoId, targetQuality.quality, videoFormat, 'file.mp4');
    }

    return '';
}
/**
 *
 * @param {boolean} needsEventUpdate
 * @param {HTMLVideoElement} videoNode
 * @param {HTMLDivElement} posterNode
 * @param {string} animatePoster
 * @param {boolean} autoplay
 * @param {boolean} isEditorMode
 */


function handlePosterVisibility(needsEventUpdate, videoNode, posterNode, animatePoster, autoplay, isEditorMode) {
    //todo: (preview -> Editor case) move to editor layout hooks
    //bring back the poster (preview -> Editor case)
    if (isEditorMode && videoNode.paused) {
        posterNode.style.opacity = '1';
        videoNode.style.opacity = '0';
    } //todo: (preview -> Editor case) move to editor layout hooks
    //register to events when updating src or when in Editor(preview -> Editor case)


    var isPausedOrEmpty = videoNode.paused || videoNode.currentSrc === '';
    var needsEventUpdateWithEditor = needsEventUpdate || isEditorMode;

    if (needsEventUpdateWithEditor && isPausedOrEmpty) {
        videoNode.ontimeupdate = null;
        videoNode.onseeked = null;
        videoNode.onplay = null;

        if (!isEditorMode && autoplay) {
            var muteState = videoNode.muted;
            videoNode.muted = true; //sync the poster removal with video first frame

            videoNode.ontimeupdate = function() {
                if (videoNode.currentTime > 0) {
                    videoNode.ontimeupdate = null;

                    videoNode.onseeked = function() {
                        videoNode.onseeked = null;
                        videoNode.muted = muteState;
                        removePoster(videoNode, posterNode, animatePoster);
                    };

                    videoNode.currentTime = 0;
                }
            };
        } else {
            videoNode.onplay = function() {
                videoNode.onplay = null;
                removePoster(videoNode, posterNode, animatePoster);
            };
        }
    }
}
/**
 * Load the video if needed.
 *
 * @param {boolean} needsSrcUpdate
 * @param {HTMLVideoElement} videoNode
 * @param {string} newSrc
 */


function patchVideoSource(needsSrcUpdate, videoNode, newSrc) {
    if (needsSrcUpdate) {
        videoNode.src = newSrc;
        videoNode.load();
    }
}
/**
 * Show video , hide poster
 *
 * @param videoNode
 * @param posterNode
 * @param animatePoster
 */


function removePoster(videoNode, posterNode, animatePoster) {
    if (animatePoster === 'fade') {
        posterNode.style.transition = 'opacity 1.6s ease-out';
    }

    posterNode.style.opacity = '0';
    videoNode.style.opacity = '1';
}
/**
 *
 * @param {{width: number, height: number}} src source dimensions
 * @param {{width: number, height: number}} target target dimensions
 * @param {{x: number, y: number}} focalPoint x/y as 0-100 percentages
 * @returns {string} in 'x% y%' format
 */


function convertFillFocalToPosition(src, target, focalPoint) {
    var sW = src.width,
        sH = src.height;
    var tW = target.width,
        tH = target.height;
    var fpX = focalPoint.x,
        fpY = focalPoint.y;

    if (!tW || !tH) {
        return fpX + "% " + fpY + "%";
    }

    var fillScaleFactor = Math.max(tW / sW, tH / sH);
    var imgScaledW = sW * fillScaleFactor;
    var imgScaledH = sH * fillScaleFactor;
    var x = Math.max(0, Math.min(imgScaledW - tW, imgScaledW * (fpX / 100) - tW / 2));
    var y = Math.max(0, Math.min(imgScaledH - tH, imgScaledH * (fpY / 100) - tH / 2));
    var posX = x && Math.floor(x / (imgScaledW - tW) * 100);
    var posY = y && Math.floor(y / (imgScaledH - tH) * 100);
    return posX + "% " + posY + "%";
}
//# sourceMappingURL=videoLayout.js.map